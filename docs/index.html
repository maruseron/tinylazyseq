<!DOCTYPE html><html class="default no-js"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>tinylazyseq</title><meta name="description" content="Documentation for tinylazyseq"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="assets/style.css"/><link rel="stylesheet" href="assets/highlight.css"/><script async src="assets/search.js" id="search-script"></script></head><body><script>document.body.classList.add(localStorage.getItem("tsd-theme") || "os")</script><header><div class="tsd-page-toolbar"><div class="container"><div class="table-wrap"><div class="table-cell" id="tsd-search" data-base="."><div class="field"><label for="tsd-search-field" class="tsd-widget search no-caption">Search</label><input type="text" id="tsd-search-field"/></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="index.html" class="title">tinylazyseq</a></div><div class="table-cell" id="tsd-widgets"><div id="tsd-filter"><a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a><div class="tsd-filter-group"><div class="tsd-select" id="tsd-filter-visibility"><span class="tsd-select-label">All</span><ul class="tsd-select-list"><li data-value="public">Public</li><li data-value="protected">Public/Protected</li><li data-value="private" class="selected">All</li></ul></div> <input type="checkbox" id="tsd-filter-inherited" checked/><label class="tsd-widget" for="tsd-filter-inherited">Inherited</label><input type="checkbox" id="tsd-filter-externals" checked/><label class="tsd-widget" for="tsd-filter-externals">Externals</label></div></div><a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a></div></div></div></div><div class="tsd-page-title"><div class="container"><h1>tinylazyseq</h1></div></div></header><div class="container container-main"><div class="row"><div class="col-8 col-content"><div class="tsd-panel tsd-typography">
<a href="#tinylazyseq" id="tinylazyseq" style="color: inherit; text-decoration: none;">
  <h1>TinyLazySeq</h1>
</a>
<p>Small ES6 library that provides generator-based lazy sequences, allowing functional intermediate operation composition computed on demand. For more information, <a href="https://maruseron.github.io/tinylazyseq/classes/Sequence.html">here is the documentation</a>.</p>

<a href="#tiny-note-of-warning" id="tiny-note-of-warning" style="color: inherit; text-decoration: none;">
  <h2>Tiny note of warning:</h2>
</a>
<p>Although I couldn&#39;t find any errors before publishing this project, I have not intensely tested this library. As such, there is a slim chance you run into a bug. If so, please let me know and I&#39;ll publish a patch as soon as I can. This warning will stay here until I feel the library is perfectly safe <em>or</em> I finally make a test suite for it.</p>

<a href="#getting-started" id="getting-started" style="color: inherit; text-decoration: none;">
  <h2>Getting Started</h2>
</a>
<p>To add TinyLazySeq to your project, just run the following command in your project folder:</p>
<pre><code><span class="hl-0">npm</span><span class="hl-1"> </span><span class="hl-0">install</span><span class="hl-1"> </span><span class="hl-0">tinylazyseq</span>
</code></pre>

<a href="#laziness" id="laziness" style="color: inherit; text-decoration: none;">
  <h2>Laziness</h2>
</a>
<p>The key difference between sequences and other iterables is their laziness - because of their lazy nature, sequences will do the minimal amount of work necessary to produce results, computing them on demand instead of eagerly producing the entire output.<br>The drawback to this is that, overall, sequences are less performant than an eager collection when consuming the entire input. The advantage, however, is that lazy sequences won&#39;t halt the result production while all values get computed. To better explain what I mean, here&#39;s an example in pseudocode:</p>
<pre><code class="language-js"><span class="hl-2">var</span><span class="hl-1"> </span><span class="hl-0">range</span><span class="hl-1"> = </span><span class="hl-3">inclusiveRange</span><span class="hl-1">(</span><span class="hl-4">1</span><span class="hl-1">, </span><span class="hl-4">10</span><span class="hl-1">)</span><br/><br/><span class="hl-2">var</span><span class="hl-1"> </span><span class="hl-0">list</span><span class="hl-1"> = </span><span class="hl-0">range</span><span class="hl-1">.</span><span class="hl-3">toList</span><span class="hl-1">()</span><br/><span class="hl-2">var</span><span class="hl-1"> </span><span class="hl-0">seq</span><span class="hl-1">  = </span><span class="hl-0">range</span><span class="hl-1">.</span><span class="hl-3">toSequence</span><span class="hl-1">()</span><br/><br/><span class="hl-0">list</span><span class="hl-1">.</span><span class="hl-3">filter</span><span class="hl-1">(</span><span class="hl-0">num</span><span class="hl-1"> -&gt; </span><span class="hl-0">num</span><span class="hl-1"> % </span><span class="hl-4">2</span><span class="hl-1"> == </span><span class="hl-4">0</span><span class="hl-1">).</span><span class="hl-3">map</span><span class="hl-1">(</span><span class="hl-0">num</span><span class="hl-1"> -&gt; </span><span class="hl-0">num</span><span class="hl-1"> * </span><span class="hl-0">num</span><span class="hl-1">)</span><br/><span class="hl-0">seq</span><span class="hl-1">.</span><span class="hl-3">filter</span><span class="hl-1">(</span><span class="hl-0">num</span><span class="hl-1"> -&gt; </span><span class="hl-0">num</span><span class="hl-1"> % </span><span class="hl-4">2</span><span class="hl-1"> == </span><span class="hl-4">0</span><span class="hl-1">).</span><span class="hl-3">map</span><span class="hl-1">(</span><span class="hl-0">num</span><span class="hl-1"> -&gt; </span><span class="hl-0">num</span><span class="hl-1"> * </span><span class="hl-0">num</span><span class="hl-1">)</span>
</code></pre>
<p>These seemingly identical operations do, broadly, the same thing: they filter a collection of numbers from 1 to 10, keeping only even numbers, and then multiply those numbers by themselves. If we were to exhaust both collections with a forEach, we&#39;d get the same output:</p>
<pre><code class="language-js"><span class="hl-0">list</span><span class="hl-1">.</span><span class="hl-3">forEach</span><span class="hl-1">(</span><span class="hl-0">print</span><span class="hl-1">) </span><span class="hl-5">// 4, 16, 36, 64, 100</span><br/><span class="hl-0">seq</span><span class="hl-1">.</span><span class="hl-3">forEach</span><span class="hl-1">(</span><span class="hl-0">print</span><span class="hl-1">)  </span><span class="hl-5">// 4, 16, 36, 64, 100</span>
</code></pre>
<p>However, if we add a log to each operation, we can clearly see the different nature of both approaches:</p>
<pre><code class="language-js"><span class="hl-0">list</span><span class="hl-1">.</span><span class="hl-3">filter</span><span class="hl-1">(</span><span class="hl-0">num</span><span class="hl-1"> -&gt; { </span><br/><span class="hl-1">    </span><span class="hl-3">print</span><span class="hl-1">(</span><span class="hl-6">&quot;filtering&quot;</span><span class="hl-1">)</span><br/><span class="hl-1">    return num % 2 == 0 </span><br/><span class="hl-1">}).</span><span class="hl-3">map</span><span class="hl-1">(</span><span class="hl-0">num</span><span class="hl-1"> -&gt; {</span><br/><span class="hl-1">    </span><span class="hl-3">print</span><span class="hl-1">(</span><span class="hl-6">&quot;mapping&quot;</span><span class="hl-1">)</span><br/><span class="hl-1">    return num </span><span class="hl-2">*</span><span class="hl-1"> num</span><br/><span class="hl-1">})</span><br/><span class="hl-5">/** output:</span><br/><span class="hl-5"> * filtering, filtering, filtering, filtering, filtering</span><br/><span class="hl-5"> * filtering, filtering, filtering, filtering, filtering</span><br/><span class="hl-5"> * mapping, mapping, mapping, mapping, mapping</span><br/><span class="hl-5"> */</span><br/><br/><span class="hl-0">seq</span><span class="hl-1">.</span><span class="hl-3">filter</span><span class="hl-1">(</span><span class="hl-0">num</span><span class="hl-1"> -&gt; { </span><br/><span class="hl-1">    </span><span class="hl-3">print</span><span class="hl-1">(</span><span class="hl-6">&quot;filtering&quot;</span><span class="hl-1">)</span><br/><span class="hl-1">    return num % 2 == 0 </span><br/><span class="hl-1">}).</span><span class="hl-3">map</span><span class="hl-1">(</span><span class="hl-0">num</span><span class="hl-1"> -&gt; {</span><br/><span class="hl-1">    </span><span class="hl-3">print</span><span class="hl-1">(</span><span class="hl-6">&quot;mapping&quot;</span><span class="hl-1">)</span><br/><span class="hl-1">    return num </span><span class="hl-2">*</span><span class="hl-1"> num</span><br/><span class="hl-1">})</span><br/><span class="hl-5">/** output:</span><br/><span class="hl-5"> * none</span><br/><span class="hl-5"> */</span><br/><br/><span class="hl-0">list</span><span class="hl-1">.</span><span class="hl-3">forEach</span><span class="hl-1">(</span><span class="hl-0">print</span><span class="hl-1">) </span><br/><span class="hl-5">// 4, 16, 36, 64, 100</span><br/><br/><span class="hl-0">seq</span><span class="hl-1">.</span><span class="hl-3">forEach</span><span class="hl-1">(</span><span class="hl-0">print</span><span class="hl-1">)</span><br/><span class="hl-5">/** output:</span><br/><span class="hl-5"> * filtering, filtering, mapping, 4</span><br/><span class="hl-5"> * filtering, filtering, mapping, 16</span><br/><span class="hl-5"> * filtering, filtering, mapping, 36 </span><br/><span class="hl-5"> * filtering, filtering, mapping, 64</span><br/><span class="hl-5"> * filtering, filtering, mapping, 100</span><br/><span class="hl-5"> */</span>
</code></pre>
<p>At this point, I hope I have done a good enough job of explaining the power of lazy sequences and intermediate operations. The List approach had all values immediately available after 15 operations, while the Sequence approach had the first value as soon as 3 operations.</p>

<a href="#factories" id="factories" style="color: inherit; text-decoration: none;">
  <h2>Factories</h2>
</a>
<p>There are multiple ways of defining a sequence, but the two most commonly used are:</p>

<a href="#asyncsequenceoflttgtargs-t-sequencelttgt" id="asyncsequenceoflttgtargs-t-sequencelttgt" style="color: inherit; text-decoration: none;">
  <h4><code>Async/Sequence.of&lt;T&gt;(...args: T[]): Sequence&lt;T&gt;</code></h4>
</a>
<p>Creates a lazy sequence containing the provided arguments.</p>
<pre><code class="language-ts"><span class="hl-7">import</span><span class="hl-1"> { </span><span class="hl-0">Sequence</span><span class="hl-1"> } </span><span class="hl-7">from</span><span class="hl-1"> </span><span class="hl-6">&quot;tinylazyseq&quot;</span><span class="hl-1">;</span><br/><span class="hl-0">Sequence</span><span class="hl-1">.</span><span class="hl-3">of</span><span class="hl-1">(</span><span class="hl-4">1</span><span class="hl-1">, </span><span class="hl-4">2</span><span class="hl-1">, </span><span class="hl-4">3</span><span class="hl-1">, </span><span class="hl-4">4</span><span class="hl-1">, </span><span class="hl-4">5</span><span class="hl-1">);</span>
</code></pre>
<p>or an asynchronous one instead:</p>
<pre><code class="language-ts"><span class="hl-7">import</span><span class="hl-1"> { </span><span class="hl-0">AsyncSequence</span><span class="hl-1"> } </span><span class="hl-7">from</span><span class="hl-1"> </span><span class="hl-6">&quot;tinylazyseq&quot;</span><span class="hl-1">;</span><br/><span class="hl-0">AsyncSequence</span><span class="hl-1">.</span><span class="hl-3">of</span><span class="hl-1">(</span><span class="hl-3">promiseTask1</span><span class="hl-1">(), </span><span class="hl-3">promiseTask2</span><span class="hl-1">(), </span><span class="hl-3">promiseTask3</span><span class="hl-1">());</span>
</code></pre>

<a href="#asyncsequencefromlttgtiterable-iterablelttgt-sequencelttgt" id="asyncsequencefromlttgtiterable-iterablelttgt-sequencelttgt" style="color: inherit; text-decoration: none;">
  <h4><code>Async/Sequence.from&lt;T&gt;(iterable: Iterable&lt;T&gt;): Sequence&lt;T&gt;</code></h4>
</a>
<p>Creates a lazy sequence wrapping the provided iterable.</p>
<pre><code class="language-ts"><span class="hl-7">import</span><span class="hl-1"> { </span><span class="hl-0">Sequence</span><span class="hl-1"> } </span><span class="hl-7">from</span><span class="hl-1"> </span><span class="hl-6">&quot;tinylazyseq&quot;</span><span class="hl-1">;</span><br/><span class="hl-0">Sequence</span><span class="hl-1">.</span><span class="hl-3">from</span><span class="hl-1">(</span><span class="hl-3">getSomeIterableData</span><span class="hl-1">());</span>
</code></pre>
<p>or an asynchronous one instead</p>
<pre><code class="language-ts"><span class="hl-7">import</span><span class="hl-1"> { </span><span class="hl-0">AsyncSequence</span><span class="hl-1"> } </span><span class="hl-7">from</span><span class="hl-1"> </span><span class="hl-6">&quot;tinylazyseq&quot;</span><span class="hl-1">;</span><br/><span class="hl-0">AsyncSequence</span><span class="hl-1">.</span><span class="hl-3">from</span><span class="hl-1">(</span><span class="hl-3">getSomePromiseArray</span><span class="hl-1">());</span>
</code></pre>
<p>Since the rest of Sequence factories are as straightforward as these, I think the inline docs do a good enough job of explaining how they work.</p>

<a href="#api" id="api" style="color: inherit; text-decoration: none;">
  <h2>API</h2>
</a>
<p>A full description of all methods can be found <a href="https://maruseron.github.io/tinylazyseq/classes/Sequence.html">here</a>.</p>
<p>The Sequence API is very similar to the Array API, so if you know how to use a functional approach with a JavaScript array, you pretty much already know how to use a Sequence. Here&#39;s a comparison table between Array and Sequence:</p>
<table>
<thead>
<tr>
<th>Method or property</th>
<th>Array</th>
<th>Sequence</th>
</tr>
</thead>
<tbody><tr>
<td>length</td>
<td>yes</td>
<td>no*</td>
</tr>
<tr>
<td>from</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>of</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>at</td>
<td>yes</td>
<td>no, but elementAt</td>
</tr>
<tr>
<td>concat</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>contains</td>
<td>no, but includes</td>
<td>yes</td>
</tr>
<tr>
<td>containsAll</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>copyWithin</td>
<td>yes</td>
<td>no, immutable</td>
</tr>
<tr>
<td>count</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>drop</td>
<td>no, but slice</td>
<td>yes</td>
</tr>
<tr>
<td>dropWhile</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>elementAt</td>
<td>no, but at</td>
<td>yes</td>
</tr>
<tr>
<td>entries</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>every</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>fill</td>
<td>yes</td>
<td>no, immutable</td>
</tr>
<tr>
<td>filter</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>find</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>findIndex</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>findLast</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>findLastIndex</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>first</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>flat / flatten</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>flatMap</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>fold</td>
<td>no, but reduce</td>
<td>yes</td>
</tr>
<tr>
<td>forEach</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>includes</td>
<td>yes</td>
<td>no, but contains</td>
</tr>
<tr>
<td>indexOf</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>isEmpty</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>join</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>last</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>lastIndexOf</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>map</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>pop</td>
<td>yes</td>
<td>no, immutable</td>
</tr>
<tr>
<td>push</td>
<td>yes</td>
<td>no, immutable</td>
</tr>
<tr>
<td>reduce</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>reduceRight</td>
<td>yes</td>
<td>no, can&#39;t be iterated backwards</td>
</tr>
<tr>
<td>reverse</td>
<td>yes</td>
<td>no, immutable</td>
</tr>
<tr>
<td>shift</td>
<td>yes</td>
<td>no, immutable</td>
</tr>
<tr>
<td>size</td>
<td>no, but length</td>
<td>yes, partially</td>
</tr>
<tr>
<td>slice</td>
<td>yes</td>
<td>no, but drop and take</td>
</tr>
<tr>
<td>some</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>sort</td>
<td>yes</td>
<td>no, immutable</td>
</tr>
<tr>
<td>splice</td>
<td>yes</td>
<td>no, immutable</td>
</tr>
<tr>
<td>take</td>
<td>no, but slice</td>
<td>yes</td>
</tr>
<tr>
<td>takeWhile</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>toLocaleString</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>toString</td>
<td>yes</td>
<td>yes, but does not provide the values</td>
</tr>
<tr>
<td>unshift</td>
<td>yes</td>
<td>no, immutable</td>
</tr>
<tr>
<td>values</td>
<td>yes</td>
<td>no</td>
</tr>
</tbody></table>
<p><font size="1">* since Sequences describe possibly unsized and/or infinite collections, it is impossible to have a length property. Instead, sequences try to infer the size of the underlying collection from their available information (eg. the collection implements size or length), providing the size if they do so succesfully, or an integer smaller than zero if the size is unknown.</font></p>

<a href="#contact" id="contact" style="color: inherit; text-decoration: none;">
  <h2>Contact</h2>
</a>
<p>I&#39;m easily contactable through Discord as maruseron#4476. Not really active anywhere else.</p>
</div></div><div class="col-4 col-menu menu-sticky-wrap menu-highlight"><nav class="tsd-navigation primary"><ul><li class="current"><a href="modules.html">Exports</a></li></ul></nav><nav class="tsd-navigation secondary menu-sticky"><ul><li class="tsd-kind-class tsd-has-type-parameter"><a href="classes/AsyncSequence.html" class="tsd-kind-icon">Async<wbr/>Sequence</a></li><li class="tsd-kind-class tsd-has-type-parameter"><a href="classes/Sequence.html" class="tsd-kind-icon">Sequence</a></li></ul></nav></div></div></div><footer class="with-border-bottom"><div class="container"><h2>Legend</h2><div class="tsd-legend-group"><ul class="tsd-legend"><li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li></ul><ul class="tsd-legend"><li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li></ul></div><h2>Settings</h2><p>Theme <select id="theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></p></div></footer><div class="container tsd-generator"><p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></div><div class="overlay"></div><script src="assets/main.js"></script></body></html>